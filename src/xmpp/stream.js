/*
 * Stream is implementation of XMPP stream as in defined in XMPP Core.
 *
 * [RFC-6120]: https://xmpp.org/rfcs/rfc6120.html
 */
class Stream {
    constructor(_config) {
        // Allow to define XMPP Core attributes directly
        this.attribute = {};
        this.attribute.from = _config.from;
        this.attribute.to = _config.to;
        // prefered language for human readable texts (if server support same language)
        this.attribute.xmllang = _config.xmllang;
        this.attribute.version = Constants.XMPP_VERSION;
        // Stream id will be generated by servers
        this.attribute.id = null;

        // XML DOM tree (cleared each time)
        this.dom = document.implementation.createDocument(null, null);

        // DOM Parser can parse XML string to DOM (created once)
        if (!this.domParser) {
            this.domParser = new DOMParser();
        }

        // Create a DOM to XML serializer (created once)
        if (!this.xmlSerializer) {
            this.xmlSerializer = new XMLSerializer();
        }
    }

    /*
     * Attributes defined by XMPP Core: from, to 
     */
    get from() {
        return this.attribute.from;
    }

    set from(_from) {
        this.attribute.from = _from;
    }

    get to() {
        return this.attribute.to;
    }

    set to(_to) {
        this.attribute.to = _to;
    }

    get xmllang() {
        return this.attribute.xmllang;
    }

    set xmllang(_xmllang) {
        this.attribute.xmllang = _xmllang;
    }

    /*
     * Public attributes not defined by XMPP Core
     */


    /*
     * Class methods
     */

    initiate() {
        return new Promise((resolve, reject) => {
            let streamRoot = this.dom.createElementNS(Constants.JABBER_CLIENT, 'stream:stream');
            streamRoot.addAttribute('xmlns:stream', Constants.NS_STREAM);
            streamRoot.addAttribute('to', this.to);
            streamRoot.addAttribute('from', this.from);
            if (this.xmllang) {
                streamRoot.addAttribute('xml:lang', this.xmllang);
            }
            streamRoot.addAttribute('version', Constants.XMPP_VERSION);

            /* TODO:
             * Whether or not the 'from' attribute is included, each entity MUST
             * verify the identity of the other entity before exchanging XML stanzas
             * with it, as described under Section 13.5.
             */

            /* TODO:
             * Whether or not the 'to' attribute is included, each entity MUST
             * verify the identity of the other entity before exchanging XML stanzas
             * with it, as described under Section 13.5.
             */

            //this.id = response.id; // Store id given by server
            resolve();
        });
    }

    restart() {
        return new Promise((resolve, reject) => {
            resolve();
        });
    }

    negotiate() {
        return new Promise((resolve, reject) => {
            resolve();
        });
    }

    authenticate() {
        return new Promise((resolve, reject) => {
            resolve();
        });
    }

    bind() {
        return new Promise((resolve, reject) => {
            resolve();
        });
    }
}
