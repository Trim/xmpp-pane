/*
 * Stream is implementation of XMPP stream as in defined in XMPP Core.
 *
 * [RFC-6120]: https://xmpp.org/rfcs/rfc6120.html
 */
class Stream {
    constructor(_config) {
        // Allow to define XMPP Core attributes directly
        this.attribute = {};
        this.attribute.from = _config.from;
        this.attribute.to = _config.to;
        // prefered language for human readable texts (if server support same language)
        this.attribute.xmllang = _config.xmllang;
        this.attribute.version = Constants.XMPP_VERSION;
        // Stream id will be generated by servers
        this.attribute.id = null;

        // XML DOM tree (cleared each time)
        this.dom = document.implementation.createDocument(null, null);

        // DOM Parser can parse XML string to DOM (created once)
        if (!this.domParser) {
            this.domParser = new DOMParser();
        }

        // Create a DOM to XML serializer (created once)
        if (!this.xmlSerializer) {
            this.xmlSerializer = new XMLSerializer();
        }
    }

    /*
     * Attributes defined by XMPP Core: from, to 
     */
    get from() {
        return this.attribute.from;
    }

    set from(_from) {
        this.attribute.from = _from;
    }

    get to() {
        return this.attribute.to;
    }

    set to(_to) {
        this.attribute.to = _to;
    }

    get xmllang() {
        return this.attribute.xmllang;
    }

    set xmllang(_xmllang) {
        this.attribute.xmllang = _xmllang;
    }

    get id() {
        return this.attribute.id;
    }

    /*
     * Public attributes not defined by XMPP Core
     */


    /*
     * Class methods
     */

    initiate() {
        return new Promise((resolve, reject) => {
            let streamRoot = this.dom.createElementNS(Constants.NS_STREAM, 'stream:stream');
            streamRoot.setAttribute('xmlns', Constants.NS_JABBER_CLIENT);
            streamRoot.setAttribute('to', this.to);
            streamRoot.setAttribute('from', this.from);
            if (this.xmllang) {
                streamRoot.setAttribute('xml:lang', this.xmllang);
            }
            streamRoot.setAttribute('version', Constants.XMPP_VERSION);

            // Stream tag will be closed when XMPP communications needs to end
            resolve(this.xmlSerializer.serializeToString(streamRoot).replace('</stream:stream>', ''));
        });
    }

    /*
     * When initiating Stream has been acknowledged, server give us the new id
     * Then, we can negotiate Stream features.
     */
    ackInitiate(ackInitiateElement) {
        return new Promise((resolve, reject) => {
            this.attribute.id = ackInitiateElement.getAttribute('id');
            console.log('stream: received id: ' + this.id);

            /* TODO:
             * Whether or not the 'from' attribute is included, each entity MUST
             * verify the identity of the other entity before exchanging XML stanzas
             * with it, as described under Section 13.5.
             */

            /* TODO:
             * Whether or not the 'to' attribute is included, each entity MUST
             * verify the identity of the other entity before exchanging XML stanzas
             * with it, as described under Section 13.5.
             */

            resolve();
        });
    }

    /*
     * To authenticate, Stream has to implement SASL.
     * To simplify SASL protocol messages, Stream temporarly handle WebSocket messages
     */
    authenticate(webSocket, saslElement) {
        return new Promise((resolve, reject) => {
            // Store current websocket message handling
            let currentWebSocketOnMessage = webSocket.onmessage;
            let clientSASLMechanism = Constants.CLIENT_PREF_SASL_MECHANISM;
            let authenticated = false;

            webSocket.onmessage = function (event) {
                console.log('stream.authenticate raw received: ' + event.data);

                // Need to parse to DOM and to sanatize content
                let messageDOM = webSocket.domParser.parseFromString(event.data, "text/xml");

                // Need to check errors in string and ask to close
                switch (messageDOM.documentElement.nodeName) {

                case 'sasl:mechanisms':
                    break;

                default:
                    console.log('stream.authenticate unknown XML element' + messageDOM.documentElement.nodeName);
                    break;
                }
            };

            // Restablish original message handler
            webSocket.onmessage = currentWebSocketOnMessage;
            if (authenticated) {
                this.restart()
                    .then(() => {
                        resolve('stream.authenticate authenticated and stream restarted.');
                    });
            }
            else {
                reject('unable to authenticate');
            }
        });
    }

    restart() {
        return new Promise((resolve, reject) => {
            resolve();
        });
    }

    negotiate() {
        return new Promise((resolve, reject) => {
            resolve();
        });
    }

    bind() {
        return new Promise((resolve, reject) => {
            resolve();
        });
    }
}
